---
layout: post
title: Blog Post 3- Identify Fake News
---


In this blog post, we are going to use machine learning techniques to build a model that identifies fake news online. We will be breaking the modeling into different parts and walk you through all the necessary steps to achieve the goal:

1. Extract the training data
2. Modify the training data into a proper dataset
3. Build and fit the models
4. Evaluate the performance of the models
5. Review what features (key words) our models have identified

Below are the packages we will be using when constructing and analyzing our model. The function of each package will be discussed individually when we use them in the following parts.


```python
import numpy as np
import pandas as pd
import tensorflow as tf

import re
import string

from tensorflow.keras.layers.experimental.preprocessing import TextVectorization
from tensorflow.keras.layers.experimental.preprocessing import StringLookup

from matplotlib import pyplot as plt
from tensorflow.keras import layers
from tensorflow.keras import losses
from tensorflow import keras

from sklearn.decomposition import PCA
import plotly.express as px 
```

## Acquire Training Data

We first retrieve the dataset. The dataset we use is hosted by Professor Chodrow at UCLA, who is my instructor for PIC 16B. To retrieve the data, we simply use `pd.read_csv()` to read the online file directly.

Note that each row is an individual instance of `news`, which includes the **title** and the **text** of the news. The value in the **fake** column tells us if the piece of news is fake news, where `fake = 1` indicates the news is fake, while `fake = 0` means the news is true.


```python
train_url = "https://github.com/PhilChodrow/PIC16b/blob/master/datasets/fake_news_train.csv?raw=true"
```


```python
df = pd.read_csv(train_url)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>title</th>
      <th>text</th>
      <th>fake</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>17366</td>
      <td>Merkel: Strong result for Austria's FPO 'big c...</td>
      <td>German Chancellor Angela Merkel said on Monday...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5634</td>
      <td>Trump says Pence will lead voter fraud panel</td>
      <td>WEST PALM BEACH, Fla.President Donald Trump sa...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>17487</td>
      <td>JUST IN: SUSPECTED LEAKER and “Close Confidant...</td>
      <td>On December 5, 2017, Circa s Sara Carter warne...</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12217</td>
      <td>Thyssenkrupp has offered help to Argentina ove...</td>
      <td>Germany s Thyssenkrupp, has offered assistance...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5535</td>
      <td>Trump say appeals court decision on travel ban...</td>
      <td>President Donald Trump on Thursday called the ...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>22444</th>
      <td>10709</td>
      <td>ALARMING: NSA Refuses to Release Clinton-Lynch...</td>
      <td>If Clinton and Lynch just talked about grandki...</td>
      <td>1</td>
    </tr>
    <tr>
      <th>22445</th>
      <td>8731</td>
      <td>Can Pence's vow not to sling mud survive a Tru...</td>
      <td>() - In 1990, during a close and bitter congre...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>22446</th>
      <td>4733</td>
      <td>Watch Trump Campaign Try To Spin Their Way Ou...</td>
      <td>A new ad by the Hillary Clinton SuperPac Prior...</td>
      <td>1</td>
    </tr>
    <tr>
      <th>22447</th>
      <td>3993</td>
      <td>Trump celebrates first 100 days as president, ...</td>
      <td>HARRISBURG, Pa.U.S. President Donald Trump hit...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>22448</th>
      <td>12896</td>
      <td>TRUMP SUPPORTERS REACT TO DEBATE: “Clinton New...</td>
      <td>MELBOURNE, FL is a town with a population of 7...</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>22449 rows × 4 columns</p>
</div>



## Make A Dataset

For this particular dataset, before we train our model on it, we need to note there is some extra preparation work we need to do:

- There are non-important words in the texts and titles. For example, the word `and` will have little significance in telling us about the truthfulness of the news. These words are known as the `stopwords`, which we need to exclude from the dataset.
- In order to pass the dataset to tensorflow (the machine learning package we use), we will transform the dataframe into a `dataset` object that can be correctly handled by tensorflow.

Let's deal with these two tasks one by one

It turns out that there's a standardized library of stopwords which we can simply import for our own use. This stopword list is from the `sklearn.feature_extraction` module.


```python
from sklearn.feature_extraction import text
stop = text.ENGLISH_STOP_WORDS
```

Now the object `stop` contains the list of stopwords, we then remove all stopwords from our dataframe simply using the `apply` method associated the dataframe object.


```python
df['text'] = df['text'].apply(lambda x: ' '.join([word for word in x.split() if word.lower() not in (stop)]))
df['title'] = df['title'].apply(lambda x: ' '.join([word for word in x.split() if word.lower() not in (stop)]))
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>title</th>
      <th>text</th>
      <th>fake</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>17366</td>
      <td>Merkel: Strong result Austria's FPO 'big chall...</td>
      <td>German Chancellor Angela Merkel said Monday st...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5634</td>
      <td>Trump says Pence lead voter fraud panel</td>
      <td>WEST PALM BEACH, Fla.President Donald Trump sa...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>17487</td>
      <td>JUST IN: SUSPECTED LEAKER “Close Confidant” Ja...</td>
      <td>December 5, 2017, Circa s Sara Carter warned m...</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12217</td>
      <td>Thyssenkrupp offered help Argentina disappeare...</td>
      <td>Germany s Thyssenkrupp, offered assistance Arg...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5535</td>
      <td>Trump say appeals court decision travel ban 'p...</td>
      <td>President Donald Trump Thursday called appella...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>22444</th>
      <td>10709</td>
      <td>ALARMING: NSA Refuses Release Clinton-Lynch Ta...</td>
      <td>Clinton Lynch just talked grandkids secret tra...</td>
      <td>1</td>
    </tr>
    <tr>
      <th>22445</th>
      <td>8731</td>
      <td>Pence's vow sling mud survive Trump campaign?</td>
      <td>() - 1990, close bitter congressional race, Mi...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>22446</th>
      <td>4733</td>
      <td>Watch Trump Campaign Try Spin Way ‘I Love War’...</td>
      <td>new ad Hillary Clinton SuperPac Priorities USA...</td>
      <td>1</td>
    </tr>
    <tr>
      <th>22447</th>
      <td>3993</td>
      <td>Trump celebrates 100 days president, blasts media</td>
      <td>HARRISBURG, Pa.U.S. President Donald Trump hit...</td>
      <td>0</td>
    </tr>
    <tr>
      <th>22448</th>
      <td>12896</td>
      <td>TRUMP SUPPORTERS REACT DEBATE: “Clinton News N...</td>
      <td>MELBOURNE, FL town population 76,000. Trump he...</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>22449 rows × 4 columns</p>
</div>



And we will convert the dataframe into a `tf.dataset` object that can be handled by tensorflow in the following way. Note that we might need to recycle the function later, we will wrap it up in a function called `make_dataset()`.


```python
def make_dataset(df):
    """
    A function that creates a fakenews tf.data.Dataset from a dataframe after excluding all stopwords
    It will also add a batch configue to the returned dataset, the size of batches being 100
    
    input: df, pd.DataFrame object
    output: tf.data.Dataset with batch_size 100
    """
    # Excluding the stopwords from the dataframe
    stop = text.ENGLISH_STOP_WORDS
    df['text'] = df['text'].apply(lambda x: ' '.join([word for word in x.split() if word.lower() not in (stop)]))
    df['title'] = df['title'].apply(lambda x: ' '.join([word for word in x.split() if word.lower() not in (stop)]))
    
    # Convert the dataframe into the Dataset object in tensorflow
    # Here, we need to tell tensorflow which columns are the inputs ("text", "title")
    # and which column is the desired out ("fake")
    data = tf.data.Dataset.from_tensor_slices(
            (
                {
                    "title" : df[["title"]],
                    "text" : df[["text"]]            
                }, 
                {
                    "fake" : df[["fake"]]
                }
            )
        )
    
    # We set the dataset batch size to 100
    # This means when we train our model, it will take one batch each time
    # And will not loop over the entire 20000+ rows every time
    data = data.batch(100)
    return data
```


```python
# We create the dataset using the above defined function
data = make_dataset(df)
```

To better assess the model during the training process, we will do a simple **train-test-split** like we did in PIC16A. The `tf.data.Dataset` has built-in methods that will allow us to do this. We will leave out 20% of the data for validation purpose.

*Note the dataset is shuffled already, we will not do the split randomly*


```python
train_size = int(0.8*len(data))
val_size   = int(0.2*len(data))

# The take(n method allows us to take the first n 'rows'
train = data.take(train_size)
# And the skip method allows us to ignore the first n 'rows' and take the rest
val   = data.skip(train_size).take(val_size)

# Check the length of the train and test dataset
len(train), len(val)
```




    (180, 45)



## Making The Models

Now, we are reaedy to make the models! Yes, model**s**. Because we are given both `text` and `title` in the dataframe, we might wonder which one will help us more when we want to identify the **fake** news. So we are going to create three models in this part:

- Model 1 will only use information from the titles;
- Model 2 will only use information from the texts;
- Model 3 will take into consideration both.

And we will be able to see how each model performs.

Before we construct didferent models, there's one last step-- `vectorization`. Because the models will not be able directly comprehend words, what matters is actually the `frequency` of the words in the dataset. To materialize this idea, we need to use the `vectorization` idea we learned in PIC16A. However, this time we have built-in function from tensorflow that will help as to achieve this.


```python
# We first specify the maximum number of different words we want to consider
# In other words, we are only going to look at the 2000 words which appear most frequently in the texts/titles
size_vocabulary = 2000

# The first step in vectorization is to standardize the texts/titles
# This is to say, we are going to make all words appear in lower cases
# and we will drop all the punctuations
# After we define the function, tensorflow will automatically apply it when necessary
def standardization(input_data):
    """
    A standardization function that converts all letters to lower cases and drop punctuations
    
    input: tf.data.Dataset object
    ouput: the same dataset in lower case with no punctuations
    """
    lowercase = tf.strings.lower(input_data)
    no_punctuation = tf.strings.regex_replace(lowercase,
                        '[%s]' % re.escape(string.punctuation),'')
    return no_punctuation 


# Then we can use the tool from tensorflow, which is called a vectorization layer
# To use the tool, all we need to do is to pass the size_vocabulary and the standardization function to it
def make_vectorization_layer():
    vectorize_layer = TextVectorization(
    standardize=standardization, # automatically apply the standardization function
    max_tokens=size_vocabulary, # only consider this many words
    output_mode='int',
    output_sequence_length=500)
    return vectorize_layer

# Then we are ready to build the models
```

{::options parse_block_html="true" /}
<div class="gave-help">
Though I don't know if this is going to make a difference, some of my classmates used a vectorization layer for all three models. I'm concerned if this will lead to information exploitation (i.e. Though we claimed that we would use data from the texts only, we are actually using both to do the vectorization). So I decided to make a vectorization layer for each of the three models.
</div>
{::options parse_block_html="false" /}


### Model 1: Let's Only Consider the Titles

The model we are going to build will look like a bunch of **layers** stacked on top of each other. For example, we first pass our dataset to a vectorization layer that vectorizes the strings. Then another layer that does the embedding. And then some other layers to identify the important words and features, etc. And using tensorflow, the process can be really simple.

Let's first create a vectorization layer using the function we defined above. Because we are using only the information from the titles, so we `adapt` the vectorization layer using only the `title` column of the dataset.


```python
vectorize_layer1 = make_vectorization_layer()
vectorize_layer1.adapt(train.map(lambda x, y: x["title"]))
```

For the model to know where to start, we will have to tell is what kind of input it should accept. In this case, it's a one-column single input, and we give this particular `input` the name `title`. Please do note that we are not passing the `title` column to the model yet, and this is just a **promise** that we will pass it something as specified here.


```python
title_input = keras.Input(
    shape = (1,), 
    name = "title",
    dtype = "string"
)
```

What should the model output be? The should have different layers to deal with the input, vectorize it, do the embedding and identify the features/important words and finally produce its prediction. Let's do this using the `layer` module form tensorflow.

Note that there is a special layer called **embedding**. This is the core layer in all of our three models. Embedding refers to a representation of a word in a vector space. Each word is assigned a vector, so we can talk about the `relative` relationships with each other and the `absolute` directions of the words, which gives suggestion about the probablity of the text/title being fake.

{::options parse_block_html="true" /}
<div class="got-help">
One of my classmate suggested that including a more detailed description of the **embedding** layer would be very helpful. And I definitely agreed!
</div>
{::options parse_block_html="false" /}


```python
# First, let's include the vectorizaion layer we definied above
title_features = vectorize_layer1(title_input)
# Then an embedding layer. We use dimension = 10 for the model
title_features = layers.Embedding(size_vocabulary, 10, name = "embedding_title")(title_features)
# Drop 20% of the indicators to avoid overfitting
title_features = layers.Dropout(0.2)(title_features)
# Let's consolidate the features using GlobalAveragePooling
title_features = layers.GlobalAveragePooling1D()(title_features)
# Drop again to avoid overfitting
title_features = layers.Dropout(0.2)(title_features)
# We pass it to a Dense Layer to do feature identification
title_features = layers.Dense(32, activation='relu')(title_features)
# Output the result, because we are dealing with 2 cases: true and false
# thus, the output whould have exactly two units
title_features = layers.Dense(2, name = "fake")(title_features)
```


```python
# Then we make a model with the specified input and output
model1 = keras.Model(
    inputs = [title_input],
    outputs = title_features
)
```

Let's take a look of the model structure!


```python
model1.summary()
```

    Model: "model"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    title (InputLayer)           [(None, 1)]               0         
    _________________________________________________________________
    text_vectorization (TextVect (None, 500)               0         
    _________________________________________________________________
    embedding_title (Embedding)  (None, 500, 10)           20000     
    _________________________________________________________________
    dropout (Dropout)            (None, 500, 10)           0         
    _________________________________________________________________
    global_average_pooling1d (Gl (None, 10)                0         
    _________________________________________________________________
    dropout_1 (Dropout)          (None, 10)                0         
    _________________________________________________________________
    dense (Dense)                (None, 32)                352       
    _________________________________________________________________
    fake (Dense)                 (None, 2)                 66        
    =================================================================
    Total params: 20,418
    Trainable params: 20,418
    Non-trainable params: 0
    _________________________________________________________________
    

Then we just need to complie and run the model. For simplicity, we will use the most traditional optimizer `adam` and a standard loss function for `category identification`. The metric `accuracy` means if we are making the right prediction or not.


```python
model1.compile(optimizer = "adam",
              loss = losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy']
)
```


```python
history = model1.fit(train,
            validation_data = val,
            epochs = 15, # we train the model 15 times using 15 different batches from the dataset
            verbose = True)
```

    Epoch 1/15
    

    C:\Users\zhaog\.conda\envs\PIC 16B\lib\site-packages\tensorflow\python\keras\engine\functional.py:588: UserWarning: Input dict contained keys ['text'] which did not match any model input. They will be ignored by the model.
      warnings.warn(
    

    180/180 [==============================] - 3s 11ms/step - loss: 0.6922 - accuracy: 0.5167 - val_loss: 0.6909 - val_accuracy: 0.5266
    Epoch 2/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.6872 - accuracy: 0.5399 - val_loss: 0.6751 - val_accuracy: 0.5284
    Epoch 3/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.6291 - accuracy: 0.7380 - val_loss: 0.5508 - val_accuracy: 0.8575
    Epoch 4/15
    180/180 [==============================] - 2s 11ms/step - loss: 0.4562 - accuracy: 0.8568 - val_loss: 0.3695 - val_accuracy: 0.8708
    Epoch 5/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.3179 - accuracy: 0.8877 - val_loss: 0.2781 - val_accuracy: 0.8908
    Epoch 6/15
    180/180 [==============================] - 2s 11ms/step - loss: 0.2544 - accuracy: 0.9075 - val_loss: 0.2311 - val_accuracy: 0.9047
    Epoch 7/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.2131 - accuracy: 0.9202 - val_loss: 0.1994 - val_accuracy: 0.9213
    Epoch 8/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.1880 - accuracy: 0.9281 - val_loss: 0.1818 - val_accuracy: 0.9278
    Epoch 9/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.1729 - accuracy: 0.9339 - val_loss: 0.1686 - val_accuracy: 0.9335
    Epoch 10/15
    180/180 [==============================] - 2s 11ms/step - loss: 0.1610 - accuracy: 0.9386 - val_loss: 0.1611 - val_accuracy: 0.9339
    Epoch 11/15
    180/180 [==============================] - 2s 11ms/step - loss: 0.1525 - accuracy: 0.9421 - val_loss: 0.1552 - val_accuracy: 0.9353
    Epoch 12/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.1443 - accuracy: 0.9434 - val_loss: 0.1513 - val_accuracy: 0.9364
    Epoch 13/15
    180/180 [==============================] - 2s 11ms/step - loss: 0.1379 - accuracy: 0.9473 - val_loss: 0.1473 - val_accuracy: 0.9382
    Epoch 14/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.1326 - accuracy: 0.9481 - val_loss: 0.1444 - val_accuracy: 0.9393
    Epoch 15/15
    180/180 [==============================] - 2s 10ms/step - loss: 0.1295 - accuracy: 0.9508 - val_loss: 0.1430 - val_accuracy: 0.9402
    

As we train the model multiple times, we can see the accuracy gradually grows and the validation accuracy is also satisfactory, let's plot the accuracy over time!


```python
plt.plot(history.history["accuracy"], label = "Training")
plt.plot(history.history["val_accuracy"], label = "Validations")
plt.legend()
plt.savefig("model1.jpg")
```


![jpg](/images/3/model1.jpg)
    


We can see from the above plot that though the accuracy on the training data will likely to increase, the accuracy on the validation dataset will not. This suggests that we might overfit the data if we do more training on the model. So we will stop here, and a **95%** accuracy on the training dataset with a **94%** accuracy on the validation dataset is not bad. 

{::options parse_block_html="true" /}
<div class="got-help">
In the draft version, I forgot to include the legend in the graph and one of my classmate pointed that out. I really appreciated that and the legend absolutely makes the graph more informative.
</div>
{::options parse_block_html="false" /}

### Model 2: Only the Texts?

Then, we will follow the same process to create our second model, but this time, we are only using the `text` part of the dataset.


```python
# Another vectorization layer, and this time feeding it only with the text part
vectorize_layer2 = make_vectorization_layer()
vectorize_layer2.adapt(train.map(lambda x, y: x["text"]))
```


```python
# A single input using only the texts
text_input = keras.Input(
    shape = (1,), 
    name = "text",
    dtype = "string"
)
```


```python
# First, let's include the vectorizaion layer we definied above
text_features = vectorize_layer2(text_input)
# First, let's include the vectorizaion layer we definied above
text_features = layers.Embedding(size_vocabulary, 10, name = "embedding_text")(text_features)
# Drop 20% of the indicators to avoid overfitting
text_features = layers.Dropout(0.2)(text_features)
# Let's consolidate the features using GlobalAveragePooling
text_features = layers.GlobalAveragePooling1D()(text_features)
# Drop again to avoid overfitting
text_features = layers.Dropout(0.2)(text_features)
# We pass it to a Dense Layer to do feature identification
text_features = layers.Dense(32, activation='relu')(text_features)
# Output the result, because we are dealing with 2 cases: true and false
text_features = layers.Dense(2, name = "fake")(text_features)
```


```python
# Declare the model
model2 = keras.Model(
    inputs = text_input,
    outputs = text_features
)
```


```python
# Take a look at the model structure
model2.summary()
```

    Model: "model_1"
    _________________________________________________________________
    Layer (type)                 Output Shape              Param #   
    =================================================================
    text (InputLayer)            [(None, 1)]               0         
    _________________________________________________________________
    text_vectorization_1 (TextVe (None, 500)               0         
    _________________________________________________________________
    embedding_text (Embedding)   (None, 500, 10)           20000     
    _________________________________________________________________
    dropout_2 (Dropout)          (None, 500, 10)           0         
    _________________________________________________________________
    global_average_pooling1d_1 ( (None, 10)                0         
    _________________________________________________________________
    dropout_3 (Dropout)          (None, 10)                0         
    _________________________________________________________________
    dense_1 (Dense)              (None, 32)                352       
    _________________________________________________________________
    fake (Dense)                 (None, 2)                 66        
    =================================================================
    Total params: 20,418
    Trainable params: 20,418
    Non-trainable params: 0
    _________________________________________________________________
    


```python
# Compile our model2
model2.compile(optimizer = "adam",
              loss = losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy']
)
```


```python
# Train the model
history = model2.fit(train,
            validation_data = val,
            epochs = 15, 
            verbose = True)
```

    Epoch 1/15
    

    C:\Users\zhaog\.conda\envs\PIC 16B\lib\site-packages\tensorflow\python\keras\engine\functional.py:588: UserWarning: Input dict contained keys ['title'] which did not match any model input. They will be ignored by the model.
      warnings.warn(
    

    180/180 [==============================] - 5s 24ms/step - loss: 0.6367 - accuracy: 0.7114 - val_loss: 0.4699 - val_accuracy: 0.9341
    Epoch 2/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.2995 - accuracy: 0.9359 - val_loss: 0.1910 - val_accuracy: 0.9681
    Epoch 3/15
    180/180 [==============================] - 4s 22ms/step - loss: 0.1581 - accuracy: 0.9643 - val_loss: 0.1268 - val_accuracy: 0.9751
    Epoch 4/15
    180/180 [==============================] - 4s 22ms/step - loss: 0.1159 - accuracy: 0.9739 - val_loss: 0.1006 - val_accuracy: 0.9777
    Epoch 5/15
    180/180 [==============================] - 4s 22ms/step - loss: 0.0935 - accuracy: 0.9787 - val_loss: 0.0854 - val_accuracy: 0.9809
    Epoch 6/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.0782 - accuracy: 0.9826 - val_loss: 0.0759 - val_accuracy: 0.9829
    Epoch 7/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.0691 - accuracy: 0.9837 - val_loss: 0.0706 - val_accuracy: 0.9838
    Epoch 8/15
    180/180 [==============================] - 4s 23ms/step - loss: 0.0606 - accuracy: 0.9862 - val_loss: 0.0659 - val_accuracy: 0.9843
    Epoch 9/15
    180/180 [==============================] - 4s 22ms/step - loss: 0.0533 - accuracy: 0.9879 - val_loss: 0.0631 - val_accuracy: 0.9843
    Epoch 10/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.0480 - accuracy: 0.9887 - val_loss: 0.0609 - val_accuracy: 0.9836
    Epoch 11/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.0428 - accuracy: 0.9898 - val_loss: 0.0589 - val_accuracy: 0.9849
    Epoch 12/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.0389 - accuracy: 0.9914 - val_loss: 0.0579 - val_accuracy: 0.9849
    Epoch 13/15
    180/180 [==============================] - 4s 21ms/step - loss: 0.0347 - accuracy: 0.9921 - val_loss: 0.0578 - val_accuracy: 0.9847
    Epoch 14/15
    180/180 [==============================] - 4s 22ms/step - loss: 0.0322 - accuracy: 0.9924 - val_loss: 0.0575 - val_accuracy: 0.9856
    Epoch 15/15
    180/180 [==============================] - 4s 22ms/step - loss: 0.0291 - accuracy: 0.9935 - val_loss: 0.0584 - val_accuracy: 0.9845
    

This time, we seems to have even better accuracy! Let's take a look at the accuracy over time.


```python
plt.plot(history.history["accuracy"], label = "Training")
plt.plot(history.history["val_accuracy"], label = "Validations")
plt.legend()
plt.savefig("model2.jpg")
```


    
![jpg](/images/3/model2.jpg)
    


Again, we can see from the above plot that though the accuracy on the training data will likely to increase, the accuracy on the validation dataset will not. This suggests that we might overfit the data if we do more training on the model. So we will stop here, and a **99.4%** accuracy on the training dataset with a **98.5%** accuracy on the validation dataset really good. 

### Model 3: What If We Consider Both?

In our last model, we will try to incorporate information from both the `text` and the `title` in the dataset, and see what we will get!

{::options parse_block_html="true" /}
<div class="gave-help">
Some of my classmates directly combined the two models they have already trained in the above parts. Personally, though I don't think this will be make a huge difference, it's not the best thing to do because we are unfairly exploiting information gathered before and might impact the new model in subtle ways, making it difficult to evaluate its accuracy on its own. So I decided to separate the models and build a new one instead.
</div>
{::options parse_block_html="false" /}


```python
# Another vectorization layer, and this time feed it with both titles and texts
vectorize_layer3 = make_vectorization_layer()
vectorize_layer3.adapt(train.map(lambda x, y: x["title"]))
vectorize_layer3.adapt(train.map(lambda x, y: x["text"]))
```

In this model, we are going to construct a model that has two parts, one dealing with the `title` and the other part dealing with the `texts`, we will combine both parts afterwards and make the right prediction.


```python
embedding_layer = layers.Embedding(size_vocabulary, 10, name = "embedding")
```


```python
text_features = vectorize_layer3(text_input)
text_features = embedding_layer(text_features)
text_features = layers.Dropout(0.2)(text_features)
text_features = layers.GlobalAveragePooling1D()(text_features)
text_features = layers.Dropout(0.2)(text_features)
text_features = layers.Dense(32, activation='relu')(text_features)
```


```python
title_features = vectorize_layer3(title_input)
title_features = embedding_layer(title_features)
title_features = layers.Dropout(0.2)(title_features)
title_features = layers.GlobalAveragePooling1D()(title_features)
title_features = layers.Dropout(0.2)(title_features)
title_features = layers.Dense(32, activation='relu')(title_features)
```

Then, let's combine the two parts using `layers.concatenate` in tensorflow.


```python
main = layers.concatenate([text_features, title_features], axis = 1)
```

We will add a few more layers to the combined part, most noticeably, we add two more layers of dropout to avoid overfitting.


```python
main = layers.Dropout(0.2)(main)
main = layers.Dense(32, activation='relu')(main)
main = layers.Dropout(0.2)(main)
output = layers.Dense(2, name = "fake")(main)
```

The we build our model!


```python
model3 = keras.Model(
    inputs = [text_input, title_input],
    outputs = output
)
```


```python
model3.summary()
```

    Model: "model_2"
    __________________________________________________________________________________________________
    Layer (type)                    Output Shape         Param #     Connected to                     
    ==================================================================================================
    text (InputLayer)               [(None, 1)]          0                                            
    __________________________________________________________________________________________________
    title (InputLayer)              [(None, 1)]          0                                            
    __________________________________________________________________________________________________
    text_vectorization_2 (TextVecto (None, 500)          0           text[0][0]                       
                                                                     title[0][0]                      
    __________________________________________________________________________________________________
    embedding (Embedding)           (None, 500, 10)      20000       text_vectorization_2[0][0]       
                                                                     text_vectorization_2[1][0]       
    __________________________________________________________________________________________________
    dropout_4 (Dropout)             (None, 500, 10)      0           embedding[0][0]                  
    __________________________________________________________________________________________________
    dropout_6 (Dropout)             (None, 500, 10)      0           embedding[1][0]                  
    __________________________________________________________________________________________________
    global_average_pooling1d_2 (Glo (None, 10)           0           dropout_4[0][0]                  
    __________________________________________________________________________________________________
    global_average_pooling1d_3 (Glo (None, 10)           0           dropout_6[0][0]                  
    __________________________________________________________________________________________________
    dropout_5 (Dropout)             (None, 10)           0           global_average_pooling1d_2[0][0] 
    __________________________________________________________________________________________________
    dropout_7 (Dropout)             (None, 10)           0           global_average_pooling1d_3[0][0] 
    __________________________________________________________________________________________________
    dense_2 (Dense)                 (None, 32)           352         dropout_5[0][0]                  
    __________________________________________________________________________________________________
    dense_3 (Dense)                 (None, 32)           352         dropout_7[0][0]                  
    __________________________________________________________________________________________________
    concatenate (Concatenate)       (None, 64)           0           dense_2[0][0]                    
                                                                     dense_3[0][0]                    
    __________________________________________________________________________________________________
    dropout_8 (Dropout)             (None, 64)           0           concatenate[0][0]                
    __________________________________________________________________________________________________
    dense_4 (Dense)                 (None, 32)           2080        dropout_8[0][0]                  
    __________________________________________________________________________________________________
    dropout_9 (Dropout)             (None, 32)           0           dense_4[0][0]                    
    __________________________________________________________________________________________________
    fake (Dense)                    (None, 2)            66          dropout_9[0][0]                  
    ==================================================================================================
    Total params: 22,850
    Trainable params: 22,850
    Non-trainable params: 0
    __________________________________________________________________________________________________
    

Let's compile the model and do the training!


```python
model3.compile(optimizer = "adam",
              loss = losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy']
)
```


```python
history = model3.fit(train,
          epochs = 10,
          validation_data = val, 
          verbose = True)
```

    Epoch 1/10
    180/180 [==============================] - 7s 33ms/step - loss: 0.5500 - accuracy: 0.7023 - val_loss: 0.2024 - val_accuracy: 0.9452
    Epoch 2/10
    180/180 [==============================] - 6s 31ms/step - loss: 0.1485 - accuracy: 0.9511 - val_loss: 0.0854 - val_accuracy: 0.9777
    Epoch 3/10
    180/180 [==============================] - 5s 29ms/step - loss: 0.0909 - accuracy: 0.9737 - val_loss: 0.0673 - val_accuracy: 0.9816
    Epoch 4/10
    180/180 [==============================] - 5s 29ms/step - loss: 0.0694 - accuracy: 0.9787 - val_loss: 0.0601 - val_accuracy: 0.9834
    Epoch 5/10
    180/180 [==============================] - 5s 30ms/step - loss: 0.0555 - accuracy: 0.9838 - val_loss: 0.0550 - val_accuracy: 0.9843
    Epoch 6/10
    180/180 [==============================] - 5s 28ms/step - loss: 0.0458 - accuracy: 0.9877 - val_loss: 0.0555 - val_accuracy: 0.9838
    Epoch 7/10
    180/180 [==============================] - 6s 31ms/step - loss: 0.0403 - accuracy: 0.9896 - val_loss: 0.0586 - val_accuracy: 0.9820
    Epoch 8/10
    180/180 [==============================] - 5s 28ms/step - loss: 0.0341 - accuracy: 0.9913 - val_loss: 0.0536 - val_accuracy: 0.9854
    Epoch 9/10
    180/180 [==============================] - 5s 29ms/step - loss: 0.0342 - accuracy: 0.9901 - val_loss: 0.0555 - val_accuracy: 0.9870
    Epoch 10/10
    180/180 [==============================] - 6s 31ms/step - loss: 0.0262 - accuracy: 0.9942 - val_loss: 0.0580 - val_accuracy: 0.9849
    


```python
plt.plot(history.history["accuracy"],label = "Training")
plt.plot(history.history["val_accuracy"],label = "Validations")
plt.legend()
plt.savefig("model3.jpg")
```


    
![jpg](/images/3/model3.jpg)
    


Again, we can see from the above plot that though the accuracy on the training data will likely to increase, the accuracy on the validation dataset will not. This suggests that we might overfit the data if we do more training on the model. So we will stop here, and a **99.4%** accuracy on the training dataset with a **98.5%** accuracy on the validation dataset really good. 

## Evaluating the Results

Among the three models we have constructed above, we see that the second and the thrid model perform relatively better compared to the first one that only considers the `title` information. Let's use another validation dataset on the two models and see how they would perform!

The dataset can be accessed directly from Professor Chodrow's github page.


```python
test_url = "https://github.com/PhilChodrow/PIC16b/blob/master/datasets/fake_news_test.csv?raw=true"
```


```python
de = pd.read_csv(test_url)
```

Again, in order to feed it to the models, we need to make it a dataset. Here, we recycle the `makedata_set` function we wrote above.


```python
test = make_dataset(de)
```

Let's see first how the second model performs. Let the model predict the test labels, we can achieve this using `evaluate` method in tensorflow.

{::options parse_block_html="true" /}
<div class="got-help">
In my original solution, I *manually* predicted the labels and verified the accuracy. However, my classmates used a much easier approach, the `evaluate` method built in tensorflow. This is indeed a clearer and more efficient way to do evaluation!
</div>
{::options parse_block_html="false" /}


```python
model2.evaluate(test)
```

    225/225 [==============================] - 3s 15ms/step - loss: 0.0648 - accuracy: 0.9809 0s - loss: 0.0649 - accuracy: 0.98
    




    [0.06483969837427139, 0.9809345602989197]



For **Model2**, it's **98.09%** accurate on the new validation dataset. Not bad!

Let's see how **Model3** does!


```python
model3.evaluate(test)
```

    225/225 [==============================] - 4s 17ms/step - loss: 0.0717 - accuracy: 0.9814
    




    [0.07165111601352692, 0.981380045413971]



**Model3** beats **Model2** by a small margin! It scores **98.14%** accuracy on the validation dataset!

## Word Embedding PCA

In this last, part, let's visualize the features **Model3** found. What words are usually associated with fake news and what are with accurate news?

To do so, we will use the `PCA` module, which stands for `principal component analysis`, it can reduces higher dimensional weights into 1 or 2 dimensional weights, which can help us to visualize the results on a 2-D plot.


```python
weights = model3.get_layer('embedding').get_weights()[0] # get the weights from the embedding layer
vocab = vectorize_layer3.get_vocabulary()            # get the vocabulary from our data prep for later

# Apply PCA on the high-dimensional weights
pca = PCA(n_components=1)
weights = pca.fit_transform(weights)

# Create a dataframe accordingly
# Using the first weight as x value
# And the second weight as y value
embedding_df = pd.DataFrame({
    'word' : vocab, 
    'x0'   : weights[:,0],
    'x1'   : np.arange(len(weights))
})
```


```python
# Plot the weights!
fig = px.scatter(embedding_df, 
          x = "x0", 
          y = "x1", 
          size = list(np.ones(len(embedding_df))),
          size_max = 2,
          hover_name = "word")

from plotly.io import write_html
write_html(fig, "PCA.html")
fig.show()
```

{% include PCA.html %}


After reducing all the weights to 1-D values, we see words on the left are usually associated with accurate news, with specific date indicating words like `tuesday`, `friday` on the far right hand. Words on the left side seem associated with fake news, including `GOP`, `FOX` and some ambiguous expressions like `recently`, `apparently`.

It's also interesting that while `obama`, `hillary` are associated with fake news, `obamas` (or possibly `obama's`) is usually associated with the accurate reportings. That might be explained news are more accurate when they don't speak of the **Specific Person** but **Things** they did.
